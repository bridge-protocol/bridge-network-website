"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7628],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return u}});var a=r(7294);function l(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){l(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,l=function(e,t){if(null==e)return{};var r,a,l={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(l[r]=e[r]);return l}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(l[r]=e[r])}return l}var p=a.createContext({}),i=function(e){var t=a.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=i(e.components);return a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var r=e.components,l=e.mdxType,n=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),k=i(r),u=l,m=k["".concat(p,".").concat(u)]||k[u]||d[u]||n;return r?a.createElement(m,o(o({ref:t},c),{},{components:r})):a.createElement(m,o({ref:t},c))}));function u(e,t){var r=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var n=r.length,o=new Array(n);o[0]=k;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:l,o[1]=s;for(var i=2;i<n;i++)o[i]=r[i];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}k.displayName="MDXCreateElement"},8189:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return i},toc:function(){return c},default:function(){return k}});var a=r(7462),l=r(3366),n=(r(7294),r(3905)),o=["components"],s={id:"sdk-models-passport",title:"Passport",sidebar_label:"Passport"},p=void 0,i={unversionedId:"sdk-models-passport",id:"sdk-models-passport",title:"Passport",description:"The passport is the container for all passport signing and encryption keys, blockchain wallets, and encrypted claim packages.",source:"@site/docs/sdk-models-passport.md",sourceDirName:".",slug:"/sdk-models-passport",permalink:"/docs/sdk-models-passport",tags:[],version:"current",frontMatter:{id:"sdk-models-passport",title:"Passport",sidebar_label:"Passport"},sidebar:"gettingStarted",previous:{title:"Claim Package",permalink:"/docs/sdk-models-claimpackage"},next:{title:"Wallet",permalink:"/docs/sdk-models-wallet"}},c=[{value:"Constructor",id:"constructor",children:[],level:2},{value:"Properties",id:"properties",children:[],level:2},{value:"Functions",id:"functions",children:[{value:"create()",id:"create",children:[],level:3},{value:"openFile()",id:"openfile",children:[],level:3},{value:"open()",id:"open",children:[],level:3},{value:"save()",id:"save",children:[],level:3},{value:"export()",id:"export",children:[],level:3},{value:"addWallet()",id:"addwallet",children:[],level:3},{value:"getWalletForNetwork()",id:"getwalletfornetwork",children:[],level:3},{value:"getWalletAddresses()",id:"getwalletaddresses",children:[],level:3},{value:"getDecryptedClaim()",id:"getdecryptedclaim",children:[],level:3},{value:"getDecryptedClaims()",id:"getdecryptedclaims",children:[],level:3},{value:"getClaimPackage()",id:"getclaimpackage",children:[],level:3},{value:"getClaimPackages()",id:"getclaimpackages",children:[],level:3}],level:2}],d={toc:c};function k(e){var t=e.components,r=(0,l.Z)(e,o);return(0,n.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"The passport is the container for all passport signing and encryption keys, blockchain wallets, and encrypted claim packages."),(0,n.kt)("h2",{id:"constructor"},"Constructor"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Passport()")),(0,n.kt)("h2",{id:"properties"},"Properties"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"id")," (string) - the unique identifier of the passport"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"version")," (string) - the version of the passport"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"key")," (object) - an object containing the public and private key of the passport"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"wallets")," (",(0,n.kt)("a",{href:"sdk-models-wallet"},"Wallet"),"[]) - the blockchain wallets in the passport"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"claims")," (",(0,n.kt)("a",{href:"sdk-models-claimpackage"},"ClaimPackage"),"[]) - the claim packages in the passport"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"publicKey")," (string) - shortcut that returns the public key of the passport"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"privateKey")," (string) - shortcut that returns the private key of the passport")),(0,n.kt)("h2",{id:"functions"},"Functions"),(0,n.kt)("h3",{id:"create"},"create()"),(0,n.kt)("p",null,"Creates a new passport with a private key encrypted using the password"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"async create(password)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"password")," (string) - the password to encrypt the private key and unlock the passport")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"openfile"},"openFile()"),(0,n.kt)("p",null,"Opens an existing passport from a JSON file on disk"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"async openFile(filePath, password)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filePath")," (string) - the file path to load the exported passport JSON from"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"password")," (string) - the password used to unlock the private key of the passport")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"open"},"open()"),(0,n.kt)("p",null,"Opens a passport from JSON content"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"async open(passportJson, password)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"passportJson")," (string) - the JSON string of an exported passport to load"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"password")," (string) - the password used to unlock the private key of the passport")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"save"},"save()"),(0,n.kt)("p",null,"Exports and saves the passport to a JSON file on disk "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"async save(filePath)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filePath")," (string) - the file path to save the passport JSON file to")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"export"},"export()"),(0,n.kt)("p",null,"Retrieves a copy of the passport object with all unlocked wallets and non-exportable information removed"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"async export()\n")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"addwallet"},"addWallet()"),(0,n.kt)("p",null,"Adds a new blockchain ",(0,n.kt)("a",{href:"sdk-models-wallet"},"Wallet")," to the passport"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"async addWallet(network, password, privateKey)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"network")," (string) - the blockchain network of the wallet"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"password")," (string) - the password to use to encrypt the private key / unlock the wallet"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"privateKey")," (string) - if provided the wallet will be an imported blockchain wallet, otherwise a new private key is generated")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"getwalletfornetwork"},"getWalletForNetwork()"),(0,n.kt)("p",null,"Retrieves the ",(0,n.kt)("a",{href:"sdk-models-wallet"},"Wallet")," for the specified network from the passport wallets"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"getWalletForNetwork(network)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"network")," (string) - the blockchain network to retrieve the ",(0,n.kt)("a",{href:"sdk-models-wallet"},"Wallet")," for")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"getwalletaddresses"},"getWalletAddresses()"),(0,n.kt)("p",null,"Retrieves a list of the passport addresses for the specified blockchain networks"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"getWalletAddresses(networks)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"networks")," (string[]) - the networks to retrieve blockchain addresses for")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"getdecryptedclaim"},"getDecryptedClaim()"),(0,n.kt)("p",null,"Retrives a decrypted ",(0,n.kt)("a",{href:"sdk-models-claim"},"Claim")," from the passport claim packages collection"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"async getDecryptedClaim(claimTypeId, password)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"claimTypeId")," (string) - the type of the claim to retrieve from the passport collection"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"password")," (string) - the password of the passport private key used to decrypt the claim package")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"getdecryptedclaims"},"getDecryptedClaims()"),(0,n.kt)("p",null,"Retrives multiple decrypted ",(0,n.kt)("a",{href:"sdk-models-claim"},"Claim")," objects from the passport claim packages collection"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"async getDecryptedClaims(claimTypeIds, password)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"claimTypeIds")," (string[]) - the type of the claims to retrieve from the passport collection"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"password")," (string) - the password of the passport private key used to decrypt the claim packages")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"getclaimpackage"},"getClaimPackage()"),(0,n.kt)("p",null,"Retrieves a claim package from the passport claim packages collection"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"getClaimPackage(claimTypeId)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"claimTypeId")," (string) - the type of the claim to retrieve from the passport collection")),(0,n.kt)("hr",null),(0,n.kt)("h3",{id:"getclaimpackages"},"getClaimPackages()"),(0,n.kt)("p",null,"Retrieves multiple claim packages from the claim packages collection"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"getClaimPackages(claimTypeIds)\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"claimTypeIds")," (string[]) - the type of the claims to retrieve from the passport collection")))}k.isMDXComponent=!0}}]);